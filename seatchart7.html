<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orchestra Seating Chart Designer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        :root { font-family: 'Inter', sans-serif; }
        .card {
            cursor: grab;
            transition: transform 0.1s;
            touch-action: none; /* Prevents default touch scrolling when dragging */
        }
        .card:active { cursor: grabbing; z-index: 100; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        #stage {
            min-height: 60vh;
            background-image: linear-gradient(135deg, #f0f9ff 0%, #dbeafe 100%);
            border: 4px solid #3b82f6;
            position: relative;
            overflow: hidden;
        }
        #unseated-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        /* Custom scrollbar for aesthetics */
        #unseated-list::-webkit-scrollbar { width: 6px; }
        #unseated-list::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 3px; }
        #unseated-list::-webkit-scrollbar-thumb:hover { background-color: #6b7280; }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">

    <div id="app-container" class="w-full mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-indigo-700">Orchestra Seating Designer</h1>
            <p class="text-gray-500 mt-2">Manage multiple classes, drag cards onto the stage, and the layout saves automatically.</p>
        </header>

        <!-- Loading/Message Area -->
        <div id="status-message" class="text-center p-3 mb-4 rounded-lg text-sm font-medium bg-yellow-100 text-yellow-800 hidden">
            Initializing application...
        </div>

        <!-- NEW: Class Management Section -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-800 mb-3">0. Select or Create Class</h2>
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                <select id="class-selector" class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-lg font-medium">
                    <!-- Options populated by JavaScript -->
                </select>
                <button id="add-class-btn" class="px-6 py-3 bg-indigo-500 text-white font-bold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md w-full sm:w-auto">
                    + Add New Class
                </button>
            </div>
            <p id="current-class-info" class="text-lg font-semibold text-gray-600 mt-4">Current Class: Loading...</p>
        </div>


        <!-- Input and Control Area -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-800 mb-3">1. Add Musicians</h2>
            <div class="flex flex-col md:flex-row gap-4">
                <textarea id="name-input" placeholder="Paste names from a spreadsheet (one name per line)" rows="4" class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                <div class="flex flex-col space-y-2">
                    <button id="add-names-btn" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
                        Add Names
                    </button>
                    <button id="seat-all-btn" class="px-6 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
                        Seat All Unseated
                    </button>
                    <button id="clear-unseated-btn" class="px-6 py-3 bg-yellow-600 text-white font-bold rounded-lg hover:bg-yellow-700 transition duration-150 shadow-md">
                        Clear Unseated List
                    </button>
                    <button id="clear-stage-btn" class="px-6 py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-150 shadow-md">
                        Clear Seating
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Seating Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">

            <!-- Unseated Musicians List (Left Column) - Takes up 1 column -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg border border-gray-200">
                <div class="p-4 border-b bg-gray-50 rounded-t-xl">
                    <h2 class="text-xl font-semibold text-gray-800">2. Unseated Musicians (<span id="unseated-count">0</span>)</h2>
                    <p class="text-sm text-gray-500">Drag cards onto the stage.</p>
                </div>
                <div id="unseated-list" class="p-4 flex flex-wrap gap-2">
                    <!-- Cards will be rendered here -->
                </div>
            </div>

            <!-- Stage Area (Right/Main Column) -->
            <div class="lg:col-span-3">
                <div class="p-4 bg-indigo-500 rounded-t-xl text-white shadow-xl">
                    <h2 class="text-xl font-bold">3. The Orchestra Stage</h2>
                    <p class="text-sm">Seated Musicians (<span id="seated-count">0</span>). **Double-click/Double-tap** a card to unseat it.</p>
                </div>
                <div id="stage" class="rounded-b-xl shadow-2xl" ondrop="drop(event)" ondragover="allowDrop(event)">
                    <!-- Seating chart visualization goes here -->
                    <div class="absolute inset-0 flex items-center justify-center text-gray-400 text-3xl font-light pointer-events-none">
                        Drop Name Cards Here
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script type="module">
        // Data persistence key for local storage
        const STORAGE_KEY = 'ORCHESTRA_SEATING_CHART_MULTICLASS_DATA'; 
        
        const statusMessage = document.getElementById('status-message');
        const unseatedList = document.getElementById('unseated-list');
        const stage = document.getElementById('stage');
        const unseatedCountSpan = document.getElementById('unseated-count');
        const seatedCountSpan = document.getElementById('seated-count');
        const classSelector = document.getElementById('class-selector');
        const currentClassInfo = document.getElementById('current-class-info');

        // Global State Management
        let appState = {
            currentClassId: null,
            classes: {} // Keyed by ID: { id: { name: '...', musicians: [...] } }
        };

        // --- Utility Functions ---

        /** Generates a simple, cross-browser unique ID. */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        function showStatus(message, type = 'info') {
            let bgColor = 'bg-yellow-100 text-yellow-800';
            if (type === 'success') bgColor = 'bg-green-100 text-green-800';
            if (type === 'error') bgColor = 'bg-red-100 text-red-800';
            statusMessage.className = `text-center p-3 mb-4 rounded-lg text-sm font-medium ${bgColor}`;
            statusMessage.textContent = message;
            statusMessage.style.display = 'block';
        }

        /** Creates a custom confirmation modal instead of using alert/confirm. */
        const confirmClear = (message) => {
            const modal = document.createElement('div');
            modal.className = "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50";
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
                    <p class="text-lg font-semibold mb-4">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button id="modal-cancel" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                        <button id="modal-confirm" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Confirm</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            return new Promise(resolve => {
                document.getElementById('modal-confirm').onclick = () => {
                    document.body.removeChild(modal);
                    resolve(true);
                };
                document.getElementById('modal-cancel').onclick = () => {
                    document.body.removeChild(modal);
                    resolve(false);
                };
            });
        };

        /** * Creates a custom input modal to replace the problematic prompt().
         * @returns {Promise<string | null>} The user input string or null if canceled.
         */
        const promptInput = (message, placeholder = "") => {
            const modal = document.createElement('div');
            modal.className = "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50";
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full">
                    <p class="text-lg font-bold text-gray-800 mb-4">${message}</p>
                    <input id="modal-input" type="text" placeholder="${placeholder}" 
                           class="w-full p-3 mb-6 border-2 border-indigo-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-700">
                    <div class="flex justify-end space-x-3">
                        <button id="modal-cancel" class="px-4 py-2 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 transition">Cancel</button>
                        <button id="modal-confirm" class="px-4 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition">Create Class</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            const inputElement = document.getElementById('modal-input');
            inputElement.focus();

            // Handle 'Enter' key press on the input field
            inputElement.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('modal-confirm').click();
                }
            });

            return new Promise(resolve => {
                const cleanup = (result) => {
                    document.body.removeChild(modal);
                    resolve(result);
                };

                document.getElementById('modal-confirm').onclick = () => {
                    const value = inputElement.value.trim();
                    if (value) {
                        cleanup(value);
                    } else {
                        // Optionally add visual feedback for empty input
                        inputElement.classList.add('border-red-500');
                        inputElement.placeholder = "Name cannot be empty!";
                    }
                };
                document.getElementById('modal-cancel').onclick = () => {
                    cleanup(null);
                };
            });
        };

        // --- Data Persistence (LocalStorage) ---
        
        /** Loads data from local storage on startup. */
        async function initApp() {
            showStatus("Initializing application and loading class data...");
            try {
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    const loadedState = JSON.parse(storedData);
                    appState = {
                        ...appState, // Ensure default properties are present
                        ...loadedState, // Overwrite with loaded data
                        classes: loadedState.classes || {} // Ensure classes object exists
                    };

                    // Check if currentClassId points to a valid class
                    if (!appState.classes[appState.currentClassId] || Object.keys(appState.classes).length === 0) {
                        appState.currentClassId = null; // Force creation of default below
                    }
                    showStatus("Data loaded from local storage.", 'success');
                }
                
                // If no classes exist, create a default one
                if (!appState.currentClassId) {
                    const defaultId = generateUniqueId();
                    appState.classes[defaultId] = { name: '1st Period', musicians: [] };
                    appState.currentClassId = defaultId;
                    showStatus(`Created default class: '1st Period'.`, 'info');
                }

                // Initial render
                renderClassSelector();
                renderMusicians();
            } catch (error) {
                console.error("Error loading from local storage:", error);
                showStatus("Error loading data. Starting fresh.", 'error');
                appState.classes = {};
                // Force creation of default
                const defaultId = generateUniqueId();
                appState.classes[defaultId] = { name: 'Default Class (Error Recovery)', musicians: [] };
                appState.currentClassId = defaultId;
                renderClassSelector();
                renderMusicians();
            }
        }

        /** Saves the current state of ALL classes to local storage. */
        async function saveAppState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
                console.log("Application state (all classes) saved to local storage.");
            } catch (error) {
                console.error("Error saving to local storage:", error);
                showStatus("Error saving data. Local storage may be full or disabled.", 'error');
            }
        }
        
        /** Helper function to get the current musicians array. */
        function getCurrentMusicians() {
            return appState.classes[appState.currentClassId]?.musicians || [];
        }

        /** Helper function to set the current musicians array and save/render. */
        async function setMusicians(newMusicians) {
            if (appState.currentClassId) {
                appState.classes[appState.currentClassId].musicians = newMusicians;
                await saveAppState();
                renderMusicians();
            }
        }

        // --- Class Management ---

        /** Populates the class selector dropdown. */
        function renderClassSelector() {
            const classId = appState.currentClassId;
            const classData = appState.classes;

            classSelector.innerHTML = ''; // Clear previous options
            let className = "No Class Selected";

            Object.keys(classData).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = classData[id].name;
                classSelector.appendChild(option);
            });

            if (classId && classData[classId]) {
                classSelector.value = classId;
                className = classData[classId].name;
            }

            currentClassInfo.textContent = `Current Class: ${className}`;
        }

        /** Switches the current class and re-renders the seating. */
        window.loadClass = async function(newId) {
            if (appState.classes[newId]) {
                appState.currentClassId = newId;
                await saveAppState(); // Save the new current ID
                renderClassSelector();
                renderMusicians();
                showStatus(`Switched to class: ${appState.classes[newId].name}`, 'info');
            }
        }

        /** Prompts for a new class name and creates it. */
        document.getElementById('add-class-btn').addEventListener('click', async () => {
            // FIX: Replaced prompt() with custom modal
            const newName = await promptInput("Enter a name for the new class:", "e.g., Spring 2024 - 1st Period");
            
            if (newName && newName.trim()) {
                const newId = generateUniqueId();
                appState.classes[newId] = { name: newName.trim(), musicians: [] };
                await loadClass(newId);
                showStatus(`New class "${newName.trim()}" created and loaded.`, 'success');
            } else if (newName === null) {
                showStatus("Class creation canceled.", 'info');
            } else {
                showStatus("Class name cannot be empty.", 'error');
            }
        });

        // --- Rendering ---

        function createCardElement(musician) {
            const card = document.createElement('div');
            card.id = `musician-${musician.id}`;
            card.className = `card px-3 py-1 bg-white rounded-lg shadow-md text-sm font-medium text-gray-700 transition duration-150 whitespace-nowrap overflow-hidden text-ellipsis border-2 border-indigo-400 hover:bg-indigo-50`;
            card.textContent = musician.name;
            card.draggable = true;
            card.setAttribute('data-id', musician.id);

            card.ondragstart = (event) => {
                event.dataTransfer.setData("text/plain", musician.id);
                // Set the drag image to the card itself
                event.dataTransfer.setDragImage(card, card.offsetWidth / 2, card.offsetHeight / 2);
            };

            // Double-click to unseat musician (for mouse users)
            card.addEventListener('dblclick', async (e) => {
                if (e.currentTarget.parentElement.id === 'stage') {
                    await updateMusicianPosition(musician.id, null, null);
                    showStatus(`${musician.name} moved back to the unseated list (Double-Click).`, 'info');
                }
            });


            // If the musician is seated, apply position styles
            if (musician.x !== undefined && musician.y !== undefined) {
                card.style.position = 'absolute';
                card.style.left = `${musician.x}px`;
                card.style.top = `${musician.y}px`;
                card.className += ' bg-yellow-100 border-yellow-500 shadow-xl'; // Different color for seated cards
            }

            // Simple touch drag handling and DOUBLE-TAP detection for mobile
            let initialX, initialY, dragStartX, dragStartY;
            let isDragging = false;
            let currentCard = null;
            let lastTapTime = 0; // Tracks last touch end time for double-tap detection

            function handleTouchStart(e) {
                currentCard = e.currentTarget;
                const touch = e.touches[0];
                const rect = currentCard.getBoundingClientRect();

                // Calculate the offset from the top-left of the card to the touch point
                initialX = touch.clientX - rect.left;
                initialY = touch.clientY - rect.top;

                // Ensure the card is absolutely positioned and on top (only applies if on stage)
                if (currentCard.parentElement.id === 'stage') {
                    currentCard.style.position = 'absolute';
                    currentCard.style.zIndex = '1000';
                }
                
                currentCard.classList.add('bg-yellow-200'); // Visual cue for dragging
                isDragging = false;
                dragStartX = touch.clientX;
                dragStartY = touch.clientY;
                e.preventDefault(); // Prevent scrolling on card touch
            }

            function handleTouchMove(e) {
                if (!currentCard) return;

                const touch = e.touches[0];
                const dx = Math.abs(touch.clientX - dragStartX);
                const dy = Math.abs(touch.clientY - dragStartY);

                // Start dragging only after a small threshold
                if ((dx > 5 || dy > 5) && !isDragging) {
                    isDragging = true;
                }

                if (isDragging) {
                    // Only calculate position relative to stage if on the stage
                    if (currentCard.parentElement.id === 'stage') {
                        let newX = touch.clientX - initialX - stage.getBoundingClientRect().left;
                        let newY = touch.clientY - initialY - stage.getBoundingClientRect().top;

                        // Constrain movement within the stage bounds
                        newX = Math.max(0, Math.min(newX, stage.offsetWidth - currentCard.offsetWidth));
                        newY = Math.min(newY, stage.offsetHeight - currentCard.offsetHeight); 

                        currentCard.style.left = `${newX}px`;
                        currentCard.style.top = `${newY}px`;
                    }
                    e.preventDefault();
                }
            }

            async function handleTouchEnd(e) {
                if (!currentCard) return;

                if (isDragging) {
                    // --- DRAG LOGIC ---
                    const rect = stage.getBoundingClientRect();
                    const cardRect = currentCard.getBoundingClientRect();

                    // Check if the card is released over the stage
                    if (cardRect.left >= rect.left && cardRect.right <= rect.right &&
                        cardRect.top >= rect.top && cardRect.bottom <= rect.bottom) {

                        // Calculate final relative position within the stage
                        const finalX = cardRect.left - rect.left;
                        const finalY = cardRect.top - rect.top;

                        // Update musician data and save
                        updateMusicianPosition(musician.id, finalX, finalY);

                    } else {
                        // Dropped outside the stage (or moved from stage to list)
                        if (currentCard.parentElement.id === 'stage') {
                             // This handles cases where a seated card is dragged outside the stage bounds and released
                             updateMusicianPosition(musician.id, null, null); 
                        }
                    }
                } else {
                    // --- DOUBLE-TAP LOGIC (Touchscreen only) ---
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTapTime;

                    // Check if it's a quick second tap (within 300ms) and the card is on the stage
                    if (tapLength < 300 && tapLength > 0 && currentCard.parentElement.id === 'stage') {
                        await updateMusicianPosition(musician.id, null, null);
                        showStatus(`${musician.name} moved back to the unseated list (Double-Tap).`, 'info');
                        lastTapTime = 0; // Reset after successful double-tap
                    } else {
                        // Not a double-tap, record the time of the first tap
                        lastTapTime = currentTime;
                    }
                }

                // Cleanup
                currentCard.style.zIndex = '';
                currentCard.classList.remove('bg-yellow-200');
                currentCard = null;
                isDragging = false;
            }

            card.addEventListener('touchstart', handleTouchStart);
            card.addEventListener('touchmove', handleTouchMove);
            card.addEventListener('touchend', handleTouchEnd);
            card.addEventListener('touchcancel', handleTouchEnd);

            return card;
        }

        function renderMusicians() {
            unseatedList.innerHTML = '';
            stage.innerHTML = ''; // Clear stage

            const currentMusicians = getCurrentMusicians();
            let unseatedCount = 0;
            let seatedCount = 0;

            currentMusicians.forEach(musician => {
                const card = createCardElement(musician);

                if (musician.x !== undefined && musician.y !== undefined) {
                    stage.appendChild(card);
                    seatedCount++;
                } else {
                    unseatedList.appendChild(card);
                    unseatedCount++;
                }
            });

            unseatedCountSpan.textContent = unseatedCount;
            seatedCountSpan.textContent = seatedCount;
        }

        // --- Drag and Drop Handlers (Desktop) ---

        window.allowDrop = function(event) {
            event.preventDefault(); // Allows drop
        };

        window.drop = async function(event) {
            event.preventDefault();
            const musicianId = event.dataTransfer.getData("text/plain");

            // Calculate card position relative to the stage container
            const stageRect = stage.getBoundingClientRect();
            const cardElement = document.getElementById(`musician-${musicianId}`);
            let offsetX = 0;
            let offsetY = 0;

            if (cardElement) {
                offsetX = cardElement.offsetWidth / 2; // Center the card roughly
                offsetY = cardElement.offsetHeight / 2;
            }

            // Calculate the final position on the stage
            let x = event.clientX - stageRect.left - offsetX;
            let y = event.clientY - stageRect.top - offsetY;

            // Ensure the position is non-negative
            x = Math.max(0, x);
            y = Math.max(0, y);

            // Bounds check for the right/bottom edge 
            const cardWidth = cardElement ? cardElement.offsetWidth : 100; 
            const cardHeight = cardElement ? cardElement.offsetHeight : 30; 

            x = Math.min(x, stage.offsetWidth - cardWidth);
            y = Math.min(y, stage.offsetHeight - cardHeight);

            await updateMusicianPosition(musicianId, x, y);
        };

        // --- Data Manipulation ---

        async function updateMusicianPosition(id, x, y) {
            const currentMusicians = getCurrentMusicians();
            const index = currentMusicians.findIndex(m => m.id === id);
            if (index !== -1) {
                let updatedMusicians = [...currentMusicians];

                if (x === null && y === null) {
                    // Unseat: delete x and y properties
                    const { x: _, y: __, ...rest } = updatedMusicians[index];
                    updatedMusicians[index] = rest;
                } else {
                    // Seat: set x and y properties
                    updatedMusicians[index].x = Math.round(x);
                    updatedMusicians[index].y = Math.round(y);
                }
                
                await setMusicians(updatedMusicians);
            }
        }

        /** Automatically seats all unseated musicians onto the stage in a simple grid pattern. */
        async function seatAllUnseated() {
            const STAGE_PADDING = 10;
            const CARD_WIDTH = 100; // Estimate width for calculation
            const CARD_HEIGHT = 30; // Estimate height for calculation
            const SPACING = 20; // Space between cards

            const stageRect = stage.getBoundingClientRect();
            const stageWidth = stage.offsetWidth;
            const stageHeight = stage.offsetHeight;

            const usableWidth = stageWidth - 2 * STAGE_PADDING;
            const cardsPerRow = Math.floor(usableWidth / (CARD_WIDTH + SPACING));
            
            if (cardsPerRow < 1) {
                showStatus("Stage is too narrow to automatically seat musicians.", 'error');
                return;
            }

            let unseatedIndex = 0;
            let changesMade = false;
            const currentMusicians = getCurrentMusicians();

            const updatedMusicians = currentMusicians.map(m => {
                if (m.x === undefined && m.y === undefined) {
                    
                    const col = unseatedIndex % cardsPerRow;
                    const row = Math.floor(unseatedIndex / cardsPerRow);

                    const x = STAGE_PADDING + col * (CARD_WIDTH + SPACING);
                    const y = STAGE_PADDING + row * (CARD_HEIGHT + SPACING);

                    if (y + CARD_HEIGHT + STAGE_PADDING > stageHeight) {
                        return m; // Stop seating if we run out of vertical space
                    }
                    
                    changesMade = true;
                    unseatedIndex++;
                    return { ...m, x: Math.round(x), y: Math.round(y) };
                }
                return m;
            });

            if (changesMade) {
                await setMusicians(updatedMusicians);
                showStatus(`Automatically seated ${unseatedIndex} musician(s) onto the stage in a grid pattern.`, 'success');
            } else {
                showStatus("All musicians are already seated.", 'info');
            }
        }

        // --- Event Listeners ---

        classSelector.addEventListener('change', (e) => {
            loadClass(e.target.value);
        });

        document.getElementById('add-names-btn').addEventListener('click', async () => {
            const input = document.getElementById('name-input').value.trim();
            if (!input) {
                showStatus("Please paste names into the box first.", 'info');
                return;
            }

            const newNames = input.split('\n')
                .map(line => line.trim())
                .filter(name => name.length > 0)
                .map(name => ({
                    id: generateUniqueId(), 
                    name: name
                }));

            if (newNames.length > 0) {
                const currentMusicians = getCurrentMusicians();
                await setMusicians([...currentMusicians, ...newNames]);
                document.getElementById('name-input').value = ''; // Clear input
                showStatus(`Added ${newNames.length} new musicians to "${appState.classes[appState.currentClassId].name}".`, 'success');
            }
        });

        document.getElementById('seat-all-btn').addEventListener('click', seatAllUnseated);
        
        document.getElementById('clear-unseated-btn').addEventListener('click', async () => {
            const confirmed = await confirmClear(`Are you sure you want to remove ALL unseated musicians from the list in "${appState.classes[appState.currentClassId].name}"? This action cannot be undone.`);

            if (confirmed) {
                const currentMusicians = getCurrentMusicians();
                const initialCount = currentMusicians.length;
                
                // Filter the musicians list to keep ONLY those who are seated (have x and y coordinates)
                const updatedMusicians = currentMusicians.filter(m => m.x !== undefined && m.y !== undefined);
                
                const removedCount = initialCount - updatedMusicians.length;

                if (removedCount > 0) {
                    await setMusicians(updatedMusicians);
                    showStatus(`Successfully removed ${removedCount} unseated musician(s) from the list.`, 'success');
                } else {
                    showStatus("The unseated list is already empty.", 'info');
                }
            }
        });

        document.getElementById('clear-stage-btn').addEventListener('click', async () => {
            const confirmed = await confirmClear(`Are you sure you want to clear the entire seating chart for "${appState.classes[appState.currentClassId].name}"? All positions will be reset.`);

            if (confirmed) {
                // Keep the names, but remove their positions (unseat everyone)
                const updatedMusicians = getCurrentMusicians().map(m => {
                    const { x, y, ...rest } = m;
                    return rest;
                });
                await setMusicians(updatedMusicians);
                showStatus("Seating chart cleared. All musicians are now unseated.", 'success');
            }
        });

        // Initialize the application
        initApp();
    </script>
</body>
</html>
