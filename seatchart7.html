<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ensemble Seating Chart Designer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load html2canvas for capturing HTML as an image -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Load jsPDF for creating and exporting the PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Load Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        :root { font-family: 'Inter', sans-serif; }
        .card {
            cursor: grab;
            transition: transform 0.1s;
            touch-action: none; /* Prevents default touch scrolling when dragging */
        }
        .card:active { cursor: grabbing; z-index: 100; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 4px, 0, 0.05); }
        
        /* 1. ASPECT RATIO WRAPPER: Use the padding hack to enforce 1.29:1 ratio (width/height) */
        #stage-wrapper {
            /* Height = 1 / 1.29 = 0.775 (77.5%) of the width */
            padding-top: 77.5%; 
            position: relative; /* Essential for containing the absolute stage */
            width: 100%; /* Ensure it takes full column width */
        }
        
        /* 2. STAGE ELEMENT: Absolutely positioned to fill the padded wrapper */
        #stage {
            /* Fills the space created by padding-top */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* Stage styling */
            background-color: white; 
            border: 4px solid black; 
            overflow: hidden;
        }

        #unseated-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        /* Custom scrollbar for aesthetics */
        #unseated-list::-webkit-scrollbar { width: 6px; }
        #unseated-list::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 3px; }
        #unseated-list::-webkit-scrollbar-thumb:hover { background-color: #6b7280; }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">

    <div id="app-container" class="w-full mx-auto">
        <!-- Main Application Header: Light gray background, black text -->
        <header class="text-center mb-6 bg-gray-200 p-6 rounded-xl shadow-lg border border-gray-400">
            <h1 class="text-4xl font-extrabold text-gray-900">Ensemble Seating Designer</h1>
            <p class="text-gray-700 mt-2">Manage multiple classes, drag cards onto the stage, and the layout saves automatically.</p>
        </header>

        <!-- Loading/Message Area -->
        <div id="status-message" class="text-center p-3 mb-4 rounded-lg text-sm font-medium bg-yellow-100 text-yellow-800 hidden">
            Initializing application...
        </div>

        <!-- Class Management Section with Rename/Delete/Import/Export buttons -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-800 mb-3">Ensembles & Classes</h2>
            <div class="flex flex-col gap-3">
                
                <!-- Row 1: Selector and Add Button -->
                <div class="flex flex-col sm:flex-row gap-3 items-center">
                    <select id="class-selector" class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-gray-500 focus:border-gray-500 text-lg font-medium">
                        <!-- Options populated by JavaScript -->
                    </select>
                    <!-- PRIMARY BUTTON: Black background, White text -->
                    <button id="add-class-btn" class="px-6 py-3 bg-gray-900 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-150 shadow-md w-full sm:w-auto">
                        + Add New Group
                    </button>
                </div>

                <!-- Row 2: Combined Class Management Controls (Rename, Delete, Import, Export) -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mt-3">
                    <!-- 1. Rename -->
                    <button id="rename-class-btn" class="px-4 py-2 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300 transition duration-150 shadow-sm disabled:opacity-50 border border-gray-400" disabled>
                        Rename
                    </button>
                    <!-- 2. Delete (Destructive Style) -->
                    <button id="delete-class-btn" class="px-4 py-2 border border-gray-900 text-gray-900 font-medium rounded-lg hover:bg-gray-100 transition duration-150 shadow-sm disabled:opacity-50" disabled>
                        Delete
                    </button>
                    <!-- 3. Import JSON (Using a Label + Hidden Input) -->
                    <label for="import-file-input" id="import-class-label" class="flex items-center justify-center px-4 py-2 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300 transition duration-150 shadow-sm border border-gray-400 cursor-pointer text-center disabled:opacity-50">
                        Import Group (JSON File)
                    </label>
                    <input type="file" id="import-file-input" accept=".json" class="hidden">
                    
                    <!-- 4. Download JSON Data -->
                    <button id="export-class-btn" class="px-4 py-2 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300 transition duration-150 shadow-sm border border-gray-400" disabled>
                        Export Group (JSON File)
                    </button>
                </div>

            </div>
            <p id="current-class-info" class="text-lg font-semibold text-gray-600 mt-4">Current Class: Loading...</p>
        </div>


        <!-- Input and Control Area -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-800 mb-3">1. Add Musicians & Utilities</h2>
            <div class="flex flex-col md:flex-row gap-4">
                <textarea id="name-input" placeholder="Paste names from a spreadsheet (one name per line)" rows="4" class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-gray-500 focus:border-gray-500"></textarea>
                <div class="flex flex-col space-y-2">
                    <!-- 1. Add Names -->
                    <button id="add-names-btn" class="px-6 py-3 bg-white text-gray-900 font-bold rounded-lg hover:bg-gray-100 transition duration-150 shadow-md border-2 border-gray-900">
                        Add Names
                    </button>
                    
                    <!-- 2. Seat All Unseated -->
                    <button id="seat-all-btn" class="px-6 py-3 bg-white text-gray-900 font-bold rounded-lg hover:bg-gray-100 transition duration-150 shadow-md border-2 border-gray-900">
                        Seat All Unseated
                    </button>

                    <!-- 3. Clear Unseated List -->
                    <button id="clear-unseated-btn" class="px-6 py-3 bg-white text-gray-900 font-bold rounded-lg hover:bg-gray-100 transition duration-150 shadow-md border-2 border-gray-900">
                        Clear Unseated List
                    </button>
                    
                    <!-- 4. Clear Seating -->
                    <button id="clear-stage-btn" class="px-6 py-3 bg-white text-gray-900 font-bold rounded-lg hover:bg-gray-100 transition duration-150 shadow-md border-2 border-gray-900">
                        Clear Seating
                    </button>
                    <!-- NOTE: Download Chart Image button moved to the stage header -->
                </div>
            </div>
        </div>

        <!-- Main Seating Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">

            <!-- Unseated Musicians List (Left Column) - Takes up 1 column -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg border border-gray-200">
                <div class="p-4 border-b bg-gray-50 rounded-t-xl">
                    <h2 class="text-xl font-semibold text-gray-800">2. Unseated Musicians (<span id="unseated-count">0</span>)</h2>
                    <p class="text-sm text-gray-500">Drag cards onto the stage.</p>
                </div>
                <div id="unseated-list" class="p-4 flex flex-wrap gap-2">
                    <!-- Cards will be rendered here -->
                </div>
            </div>

            <!-- Stage Area (Right/Main Column) - Takes up 3 columns -->
            <div class="lg:col-span-3">
                <!-- STAGE HEADER: Light gray background, dark text -->
                <div class="p-4 bg-gray-200 rounded-t-xl text-gray-900 shadow-xl border-b border-gray-400">
                    
                    <!-- Title and Download Button Row (NEW FLEX CONTAINER) -->
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-2 sm:mb-0">
                        <!-- MODIFIED LABEL TO INCLUDE DYNAMIC CLASS NAME -->
                        <h2 class="text-xl font-bold mb-2 sm:mb-0">3. The Ensemble Stage: <span id="stage-class-name" class="font-extrabold text-gray-900">Loading...</span></h2>
                        
                        <!-- Download Chart PDF Button (UPDATED LOCATION) -->
                        <button id="download-chart-btn" class="px-4 py-2 bg-gray-800 text-white text-sm font-bold rounded-lg hover:bg-gray-700 transition duration-150 shadow-md w-full sm:w-auto">
                            Download PDF
                        </button>
                    </div>

                    <p class="text-sm text-gray-700">Seated Musicians (<span id="seated-count">0</span>). **Double-click/Double-tap** a card to unseat it.</p>
                </div>
                
                <!-- NEW WRAPPER DIV for Aspect Ratio (1.29:1) -->
                <div id="stage-wrapper" class="rounded-b-xl shadow-2xl">
                    <!-- The stage itself is now absolutely positioned inside the wrapper -->
                    <div id="stage" ondrop="drop(event)" ondragover="allowDrop(event)">
                        
                        <!-- NEW: Class Name Label INSIDE the Stage -->
                        <div id="stage-internal-label" class="absolute top-4 left-1/2 transform -translate-x-1/2 text-2xl font-black text-gray-500/70 p-2 rounded-lg pointer-events-none z-0">
                            <!-- Name will be populated by JS -->
                        </div>

                        <!-- Seating chart visualization goes here -->
                        <div class="absolute inset-0 flex items-center justify-center text-gray-600 text-3xl font-light pointer-events-none">
                            Drop Name Cards Here
                        </div>
                    </div>
                </div>

            </div>

        </div>
    </div>
    <div><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p></div>

    <script type="module">
        // Data persistence key for local storage
        const STORAGE_KEY = 'ORCHESTRA_SEATING_CHART_MULTICLASS_DATA'; 
        
        // Ensure jsPDF is loaded before trying to use it
        const { jsPDF } = window.jspdf;

        const statusMessage = document.getElementById('status-message');
        const unseatedList = document.getElementById('unseated-list');
        const stage = document.getElementById('stage');
        const unseatedCountSpan = document.getElementById('unseated-count');
        const seatedCountSpan = document.getElementById('seated-count');
        const classSelector = document.getElementById('class-selector');
        const currentClassInfo = document.getElementById('current-class-info');
        // Reference to the span that displays the class name in the external stage header
        const stageClassNameSpan = document.getElementById('stage-class-name'); 
        // Reference to the div that displays the class name inside the stage
        const stageInternalLabel = document.getElementById('stage-internal-label');
        // Import file input reference
        const importFileInput = document.getElementById('import-file-input');


        // Global State Management
        let appState = {
            currentClassId: null,
            classes: {} // Keyed by ID: { id: { name: '...', musicians: [] } }
        };

        // --- Utility Functions ---

        /** Generates a simple, cross-browser unique ID. */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        function showStatus(message, type = 'info') {
            let bgColor = 'bg-yellow-100 text-yellow-800';
            if (type === 'success') bgColor = 'bg-green-100 text-green-800';
            if (type === 'error') bgColor = 'bg-red-100 text-red-800';
            statusMessage.className = `text-center p-3 mb-4 rounded-lg text-sm font-medium ${bgColor}`;
            statusMessage.textContent = message;
            statusMessage.style.display = 'block';
            
            // Auto-hide the message after 5 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        /** Creates a custom confirmation modal instead of using alert/confirm. */
        const confirmClear = (message, confirmText = "Confirm") => {
            const modal = document.createElement('div');
            modal.className = "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50 p-4";
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
                    <p class="text-lg font-semibold mb-4 text-gray-800">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button id="modal-cancel" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition">Cancel</button>
                        <!-- Updated to black button for confirm action -->
                        <button id="modal-confirm" class="px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-700 transition">${confirmText}</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            return new Promise(resolve => {
                document.getElementById('modal-confirm').onclick = () => {
                    document.body.removeChild(modal);
                    resolve(true);
                };
                document.getElementById('modal-cancel').onclick = () => {
                    document.body.removeChild(modal);
                    resolve(false);
                };
            });
        };

        /** Creates a custom input modal to replace the problematic prompt().
         * @returns {Promise<string | null>} The user input string or null if canceled.
         */
        const promptInput = (message, placeholder = "", confirmText = "Confirm") => {
            const modal = document.createElement('div');
            modal.className = "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50 p-4";
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full">
                    <p class="text-lg font-bold text-gray-800 mb-4">${message}</p>
                    <input id="modal-input" type="text" placeholder="${placeholder}" 
                           class="w-full p-3 mb-6 border-2 border-gray-300 rounded-lg focus:ring-gray-500 focus:border-gray-500 text-gray-700">
                    <div class="flex justify-end space-x-3">
                        <button id="modal-cancel" class="px-4 py-2 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 transition">Cancel</button>
                        <!-- Updated to black button for confirm action -->
                        <button id="modal-confirm" class="px-4 py-2 bg-gray-900 text-white font-bold rounded-lg hover:bg-gray-700 transition">${confirmText}</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            const inputElement = document.getElementById('modal-input');
            inputElement.focus();

            // Handle 'Enter' key press on the input field
            inputElement.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('modal-confirm').click();
                }
            });

            return new Promise(resolve => {
                const cleanup = (result) => {
                    document.body.removeChild(modal);
                    resolve(result);
                };

                document.getElementById('modal-confirm').onclick = () => {
                    const value = inputElement.value.trim();
                    if (value) {
                        cleanup(value);
                    } else {
                        // Optionally add visual feedback for empty input
                        inputElement.classList.add('border-red-500');
                        inputElement.placeholder = "Name cannot be empty!";
                    }
                };
                document.getElementById('modal-cancel').onclick = () => {
                    cleanup(null);
                };
            });
        };

        // --- Data Persistence (LocalStorage) ---
        
        /** Loads data from local storage on startup. */
        async function initApp() {
            showStatus("Initializing application and loading class data...");
            try {
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    const loadedState = JSON.parse(storedData);
                    appState = {
                        ...appState, // Ensure default properties are present
                        ...loadedState, // Overwrite with loaded data
                        classes: loadedState.classes || {} // Ensure classes object exists
                    };

                    // Check if currentClassId points to a valid class
                    if (!appState.classes[appState.currentClassId] || Object.keys(appState.classes).length === 0) {
                        appState.currentClassId = null; // Force creation of default below
                    }
                }
                
                // If no classes exist, create a default one
                if (!appState.currentClassId || Object.keys(appState.classes).length === 0) {
                    const defaultId = generateUniqueId();
                    appState.classes[defaultId] = { name: 'My First Class', musicians: [] };
                    appState.currentClassId = defaultId;
                    await saveAppState(); // Save the default class immediately
                    showStatus(`Created default class: 'My First Class'.`, 'info');
                } else {
                     showStatus("Data loaded from local storage.", 'success');
                }

                // Initial render
                renderClassSelector();
                renderMusicians();
            } catch (error) {
                console.error("Error loading from local storage:", error);
                showStatus("Error loading data. Starting fresh.", 'error');
                appState.classes = {};
                // Force creation of default
                const defaultId = generateUniqueId();
                appState.classes[defaultId] = { name: 'Default Class (Error Recovery)', musicians: [] };
                appState.currentClassId = defaultId;
                renderClassSelector();
                renderMusicians();
            }
        }

        /** Saves the current state of ALL classes to local storage. */
        async function saveAppState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
                // console.log("Application state (all classes) saved to local storage.");
            } catch (error) {
                console.error("Error saving to local storage:", error);
                showStatus("Error saving data. Local storage may be full or disabled.", 'error');
            }
        }
        
        /** Helper function to get the current musicians array. */
        function getCurrentMusicians() {
            return appState.classes[appState.currentClassId]?.musicians || [];
        }

        /** Helper function to set the current musicians array and save/render. */
        async function setMusicians(newMusicians) {
            if (appState.currentClassId) {
                appState.classes[appState.currentClassId].musicians = newMusicians;
                await saveAppState();
                renderMusicians();
            }
        }

        // --- Class Management ---

        /** Populates the class selector dropdown and manages action button state. */
        function renderClassSelector() {
            const classId = appState.currentClassId;
            const classData = appState.classes;

            classSelector.innerHTML = ''; // Clear previous options
            let className = "No Class Selected";
            const classKeys = Object.keys(classData);
            const isSingleClass = classKeys.length <= 1;
            const renameBtn = document.getElementById('rename-class-btn');
            const deleteBtn = document.getElementById('delete-class-btn');
            const exportBtn = document.getElementById('export-class-btn');
            const importLabel = document.getElementById('import-class-label');


            if (classKeys.length === 0) {
                 currentClassInfo.textContent = `Current Class: No Class Loaded`;
                 classSelector.disabled = true;
                 renameBtn.disabled = true;
                 deleteBtn.disabled = true;
                 exportBtn.disabled = true;
                 // Set opacity/pointer events on the label wrapper for Import
                 importLabel.classList.add('opacity-50', 'pointer-events-none');
                 return;
            }

            classSelector.disabled = false;
            
            Object.keys(classData).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = classData[id].name;
                classSelector.appendChild(option);
            });

            if (classId && classData[classId]) {
                classSelector.value = classId;
                className = classData[classId].name;
                
                // Enable/Disable buttons based on current state
                renameBtn.disabled = !classId;
                exportBtn.disabled = !classId;
                importLabel.classList.remove('opacity-50', 'pointer-events-none');
                
                // Only allow deletion if there is more than one class.
                deleteBtn.disabled = isSingleClass; 
            } else {
                renameBtn.disabled = true;
                deleteBtn.disabled = true;
                exportBtn.disabled = true;
                importLabel.classList.add('opacity-50', 'pointer-events-none');
            }

            currentClassInfo.textContent = `Current Class: ${className}`;
        }

        /** Switches the current class and re-renders the seating. */
        window.loadClass = async function(newId) {
            if (appState.classes[newId]) {
                appState.currentClassId = newId;
                await saveAppState(); // Save the new current ID
                renderClassSelector();
                renderMusicians();
                showStatus(`Switched to class: ${appState.classes[newId].name}`, 'info');
            }
        }

        /** Prompts for a new class name and creates it. */
        document.getElementById('add-class-btn').addEventListener('click', async () => {
            const newName = await promptInput("Enter a name for the new group:", "e.g., Spring 2024 - 1st Period", "Create Group");
            
            if (newName && newName.trim()) {
                const newId = generateUniqueId();
                appState.classes[newId] = { name: newName.trim(), musicians: [] };
                await loadClass(newId);
                showStatus(`New group "${newName.trim()}" created and loaded.`, 'success');
            } else if (newName === null) {
                showStatus("Group creation canceled.", 'info');
            } else {
                showStatus("Group name cannot be empty.", 'error');
            }
        });
        
        /** Prompts user to rename the current class. */
        async function renameCurrentClass() {
            if (!appState.currentClassId) return;
            const currentClass = appState.classes[appState.currentClassId];
            if (!currentClass) return;

            const newName = await promptInput(`Rename "${currentClass.name}" to:`, currentClass.name, "Rename");

            if (newName && newName.trim() && newName.trim() !== currentClass.name) {
                currentClass.name = newName.trim();
                await saveAppState();
                renderClassSelector();
                renderMusicians(); // Re-render to update the stage name
                showStatus(`Group renamed to "${newName.trim()}".`, 'success');
            } else if (newName !== null) {
                showStatus("Group name not changed.", 'info');
            }
        }

        /** Deletes the currently selected class. */
        async function deleteCurrentClass() {
            const currentClass = appState.classes[appState.currentClassId];
            const classKeys = Object.keys(appState.classes);
            
            // Safety check: ensure we are not deleting the last class
            if (classKeys.length <= 1) {
                showStatus("Cannot delete the only remaining class. Create another class first.", 'error');
                return;
            }

            const confirmed = await confirmClear(`Are you sure you want to permanently delete the group: "${currentClass.name}"? This action cannot be undone.`, "Delete Group");

            if (confirmed) {
                const oldName = currentClass.name;
                
                // 1. Delete the class from the state
                delete appState.classes[appState.currentClassId];

                // 2. Select a new current class (pick the first one remaining)
                const remainingKeys = Object.keys(appState.classes);
                appState.currentClassId = remainingKeys[0]; 

                // 3. Save and Render
                await saveAppState();
                renderClassSelector();
                renderMusicians(); 
                
                showStatus(`Group "${oldName}" was successfully deleted. Loaded class: "${appState.classes[appState.currentClassId].name}"`, 'success');
            }
        }
        
        // Attach event listeners for the new features
        document.getElementById('rename-class-btn').addEventListener('click', renameCurrentClass);
        document.getElementById('delete-class-btn').addEventListener('click', deleteCurrentClass);


        // --- Rendering ---

        function createCardElement(musician) {
            const card = document.createElement('div');
            card.id = `musician-${musician.id}`;
            // Neutralized unseated card styling to gray/white
            card.className = `card px-3 py-1 bg-white rounded-lg shadow-md text-sm font-medium text-gray-700 transition duration-150 whitespace-nowrap overflow-hidden text-ellipsis border-2 border-gray-400 hover:bg-gray-100`;
            card.textContent = musician.name;
            card.draggable = true;
            card.setAttribute('data-id', musician.id);

            card.ondragstart = (event) => {
                event.dataTransfer.setData("text/plain", musician.id);
                // Set the drag image to the card itself
                event.dataTransfer.setDragImage(card, card.offsetWidth / 2, card.offsetHeight / 2);
            };

            // Double-click to unseat musician (for mouse users)
            card.addEventListener('dblclick', async (e) => {
                if (e.currentTarget.parentElement.id === 'stage') {
                    await updateMusicianPosition(musician.id, null, null);
                    showStatus(`${musician.name} moved back to the unseated list (Double-Click).`, 'info');
                }
            });


            // If the musician is seated, apply position styles
            if (musician.x !== undefined && musician.y !== undefined) {
                card.style.position = 'absolute';
                card.style.left = `${musician.x}px`;
                card.style.top = `${musician.y}px`;
                // Black/White seated card styling
                card.className = `card px-3 py-1 rounded-lg shadow-md text-sm font-medium whitespace-nowrap overflow-hidden text-ellipsis border-2 bg-gray-200 border-gray-900 text-gray-900 shadow-xl transition duration-150`; 
            }

            // Simple touch drag handling and DOUBLE-TAP detection for mobile
            let initialX, initialY, dragStartX, dragStartY;
            let isDragging = false;
            let currentCard = null;
            let lastTapTime = 0; // Tracks last touch end time for double-tap detection

            function handleTouchStart(e) {
                currentCard = e.currentTarget;
                const touch = e.touches[0];
                const rect = currentCard.getBoundingClientRect();

                // Calculate the offset from the top-left of the card to the touch point
                initialX = touch.clientX - rect.left;
                initialY = touch.clientY - rect.top;

                // --- FIX FOR DRAGGING FROM UNSEATED LIST ---
                // If starting from the unseated list, move it to the stage container 
                // and apply absolute positioning so touchmove can track it correctly.
                if (currentCard.parentElement.id !== 'stage') {
                    const stageRect = stage.getBoundingClientRect();
                    
                    // Calculate initial x, y on stage based on touch location
                    let newX = touch.clientX - initialX - stageRect.left;
                    let newY = touch.clientY - initialY - stageRect.top;

                    // Set absolute position and move to stage container
                    currentCard.style.position = 'absolute';
                    currentCard.style.left = `${newX}px`;
                    currentCard.style.top = `${newY}px`;
                    stage.appendChild(currentCard);
                    
                    // Temporarily update musician object for internal logic if needed
                    musician.x = newX; 
                    musician.y = newY;
                }
                
                currentCard.style.zIndex = '1000'; // Bring to front
                currentCard.classList.add('bg-gray-300'); // Visual cue for dragging (neutral gray)
                isDragging = false;
                dragStartX = touch.clientX;
                dragStartY = touch.clientY;
                e.preventDefault(); // Prevent scrolling on card touch
            }

            function handleTouchMove(e) {
                if (!currentCard) return;

                const touch = e.touches[0];
                const dx = Math.abs(touch.clientX - dragStartX);
                const dy = Math.abs(touch.clientY - dragStartY);

                // Start dragging only after a small threshold
                if ((dx > 5 || dy > 5) && !isDragging) {
                    isDragging = true;
                }

                if (isDragging) {
                    // Always calculate position relative to stage now that the card is on the stage (or started there)
                    const stageRect = stage.getBoundingClientRect();
                    let newX = touch.clientX - initialX - stageRect.left;
                    let newY = touch.clientY - initialY - stageRect.top;

                    // Constrain movement within the stage bounds
                    newX = Math.max(0, Math.min(newX, stage.offsetWidth - currentCard.offsetWidth));
                    newY = Math.max(0, Math.min(newY, stage.offsetHeight - currentCard.offsetHeight)); 

                    currentCard.style.left = `${newX}px`;
                    currentCard.style.top = `${newY}px`;
                    
                    e.preventDefault();
                }
            }

            async function handleTouchEnd(e) {
                if (!currentCard) return;

                // Calculate where the center of the card ended up relative to the screen
                const cardRect = currentCard.getBoundingClientRect();
                const cardCenterX = cardRect.left + cardRect.width / 2;
                const cardCenterY = cardRect.top + cardRect.height / 2;

                const unseatedRect = unseatedList.getBoundingClientRect();
                
                if (isDragging) {
                    // Check if center of card is over the unseated list area
                    if (cardCenterX >= unseatedRect.left && cardCenterX <= unseatedRect.right &&
                        cardCenterY >= unseatedRect.top && cardCenterY <= unseatedRect.bottom) 
                    {
                        // Dropped back onto the unseated list area.
                        await updateMusicianPosition(musician.id, null, null); 

                    } else {
                        // Dropped over the stage 
                        
                        // Get the current CSS position (which is the last valid position from touchmove)
                        const finalX = parseFloat(currentCard.style.left);
                        const finalY = parseFloat(currentCard.style.top);

                        await updateMusicianPosition(musician.id, finalX, finalY);
                    }
                } else {
                    // --- DOUBLE-TAP LOGIC (Touchscreen only) ---
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTapTime;

                    // Check if it's a quick second tap (within 300ms) and the card is on the stage
                    if (tapLength < 300 && tapLength > 0 && currentCard.parentElement.id === 'stage') {
                        await updateMusicianPosition(musician.id, null, null);
                        showStatus(`${musician.name} moved back to the unseated list (Double-Tap).`, 'info');
                        lastTapTime = 0; // Reset after successful double-tap
                    } else {
                        // Not a double-tap, record the time of the first tap
                        lastTapTime = currentTime;
                    }
                }

                // Cleanup
                currentCard.style.zIndex = '';
                currentCard.classList.remove('bg-gray-300');
                currentCard = null;
                isDragging = false;
            }

            card.addEventListener('touchstart', handleTouchStart);
            card.addEventListener('touchmove', handleTouchMove);
            card.addEventListener('touchend', handleTouchEnd);
            card.addEventListener('touchcancel', handleTouchEnd);

            return card;
        }

        function renderMusicians() {
            unseatedList.innerHTML = '';
            
            // Note: We MUST NOT clear the stage's innerHTML here, as it contains the 
            // stage-internal-label and the placeholder. We only remove cards.
            // Find and remove all existing musician cards from the stage
            const existingCards = stage.querySelectorAll('.card');
            existingCards.forEach(card => card.remove());
            
            const currentMusicians = getCurrentMusicians();
            let unseatedCount = 0;
            let seatedCount = 0;
            
            // Update the class name labels
            const className = appState.classes[appState.currentClassId]?.name || "No Group Selected";
            stageClassNameSpan.textContent = className;
            stageInternalLabel.textContent = className; // Update the internal label

            currentMusicians.forEach(musician => {
                const card = createCardElement(musician);

                if (musician.x !== undefined && musician.y !== undefined) {
                    stage.appendChild(card);
                    seatedCount++;
                } else {
                    unseatedList.appendChild(card);
                    unseatedCount++;
                }
            });

            seatedCountSpan.textContent = seatedCount; // This counts musicians on the stage
            document.getElementById('unseated-count').textContent = unseatedCount; // Update the count on the unseated list title
            
            // Manage the visibility of the "Drop Name Cards Here" placeholder
            const placeholder = stage.querySelector('.absolute.inset-0');
            if (placeholder) {
                placeholder.style.display = seatedCount === 0 ? 'flex' : 'none';
            }
        }

        // --- Drag and Drop Handlers (Desktop) ---
        // Note: These rely on the browser's native drag/drop API which is often unreliable on touch devices.

        window.allowDrop = function(event) {
            event.preventDefault(); // Allows drop
        };

        window.drop = async function(event) {
            event.preventDefault();
            const musicianId = event.dataTransfer.getData("text/plain");

            // Calculate card position relative to the stage container
            const stageRect = stage.getBoundingClientRect();
            const cardElement = document.getElementById(`musician-${musicianId}`);
            let offsetX = 0;
            let offsetY = 0;

            if (cardElement) {
                offsetX = cardElement.offsetWidth / 2; // Center the card roughly
                offsetY = cardElement.offsetHeight / 2;
            } else {
                return; // Card not found, abort
            }

            // Calculate the final position on the stage
            let x = event.clientX - stageRect.left - offsetX;
            let y = event.clientY - stageRect.top - offsetY;

            // Ensure the position is non-negative
            x = Math.max(0, x);
            y = Math.max(0, y);

            // Bounds check for the right/bottom edge 
            const cardWidth = cardElement.offsetWidth; 
            const cardHeight = cardElement.offsetHeight; 

            x = Math.min(x, stage.offsetWidth - cardWidth);
            y = Math.min(y, stage.offsetHeight - cardHeight);

            await updateMusicianPosition(musicianId, x, y);
        };

        // --- Data Manipulation ---

        async function updateMusicianPosition(id, x, y) {
            const currentMusicians = getCurrentMusicians();
            const index = currentMusicians.findIndex(m => m.id === id);
            if (index !== -1) {
                let updatedMusicians = [...currentMusicians];

                if (x === null && y === null) {
                    // Unseat: delete x and y properties
                    const { x: _, y: __, ...rest } = updatedMusicians[index];
                    updatedMusicians[index] = rest;
                } else {
                    // Seat: set x and y properties
                    updatedMusicians[index].x = Math.round(x);
                    updatedMusicians[index].y = Math.round(y);
                }
                
                await setMusicians(updatedMusicians);
            }
        }
        
        /** Converts the stage into a PDF document and triggers a download. (UPDATED Function) */
        async function downloadChartPDF() {
            const stageElement = document.getElementById('stage');
            
            showStatus("Generating PDF, please wait (this may take a few moments)...", 'info');

            // Find and temporarily hide the "Drop Name Cards Here" placeholder
            const placeholder = stageElement.querySelector('.absolute.inset-0:not(#stage-internal-label)');
            const placeholderWasVisible = placeholder && placeholder.style.display !== 'none';
            if (placeholderWasVisible) {
                placeholder.style.display = 'none';
            }

            try {
                // 1. Capture the HTML element as a canvas (high resolution)
                const canvas = await html2canvas(stageElement, {
                    scale: 2, // Use scale 2 for better resolution
                    backgroundColor: 'white' 
                });

                const imgData = canvas.toDataURL('image/png');
                
                // 2. Initialize jsPDF (US Letter size in landscape orientation)
                // Unit is 'pt' (points), size is 'letter', orientation is 'landscape' (11x8.5)
                const pdf = new jsPDF('landscape', 'pt', 'letter');
                
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();

                // Get the dimensions of the captured image
                const imgProps = pdf.getImageProperties(imgData);
                const imgWidth = imgProps.width;
                const imgHeight = imgProps.height;

                // 3. Calculate scaling factor to fit the stage aspect ratio (1.29:1) within the PDF (1.294:1)
                // We fit by width since the stage is designed to be landscape-oriented (W > H)
                const ratio = imgWidth / imgHeight; // Should be ~1.29
                
                // Use most of the PDF width (95% to allow for margins)
                const chartWidth = pdfWidth * 0.95; 
                const chartHeight = chartWidth / ratio;
                
                // Calculate centering offsets
                const xOffset = (pdfWidth - chartWidth) / 2;
                const yOffset = (pdfHeight - chartHeight) / 2;

                // 4. Add the image to the PDF
                pdf.addImage(imgData, 'PNG', xOffset, yOffset, chartWidth, chartHeight);

                // 5. Get the current class name for the filename
                const className = appState.classes[appState.currentClassId]?.name || "Seating_Chart";
                // Sanitize and create filename
                const filename = `${className.replace(/[^a-z0-9]/gi, '_')}_Seating_Chart.pdf`;

                // 6. Trigger download
                pdf.save(filename);

                showStatus("Seating chart PDF downloaded successfully!", 'success');

            } catch (error) {
                console.error("Error generating PDF:", error);
                showStatus("Failed to generate and download the chart PDF. Check console for details.", 'error');
            } finally {
                // Restore the placeholder text display if it was hidden
                if (placeholderWasVisible) {
                    placeholder.style.display = 'flex'; // Restore its original display style (flex)
                }
            }
        }


        /** Automatically seats all unseated musicians onto the stage in a simple grid pattern. */
        async function seatAllUnseated() {
            const STAGE_PADDING = 10;
            const CARD_WIDTH = 100; // Estimate width for calculation
            const CARD_HEIGHT = 30; // Estimate height for calculation
            const SPACING = 20; // Space between cards

            // Use offsetWidth and offsetHeight which are correct due to the aspect ratio CSS
            const stageWidth = stage.offsetWidth;
            const stageHeight = stage.offsetHeight;

            const usableWidth = stageWidth - 2 * STAGE_PADDING;
            const cardsPerRow = Math.floor(usableWidth / (CARD_WIDTH + SPACING));
            
            if (cardsPerRow < 1) {
                showStatus("Stage is too narrow to automatically seat musicians.", 'error');
                return;
            }

            let unseatedIndex = 0;
            let changesMade = false;
            const currentMusicians = getCurrentMusicians();

            const updatedMusicians = currentMusicians.map(m => {
                if (m.x === undefined && m.y === undefined) {
                    
                    const col = unseatedIndex % cardsPerRow;
                    const row = Math.floor(unseatedIndex / cardsPerRow);

                    // Starting Y position is pushed down to accommodate the internal label
                    const START_Y_OFFSET = 50; 
                    
                    const x = STAGE_PADDING + col * (CARD_WIDTH + SPACING);
                    const y = START_Y_OFFSET + row * (CARD_HEIGHT + SPACING);

                    if (y + CARD_HEIGHT + SPACING > stageHeight) { 
                        return m; // Stop seating if we run out of vertical space
                    }
                    
                    changesMade = true;
                    unseatedIndex++;
                    return { ...m, x: Math.round(x), y: Math.round(y) };
                }
                return m;
            });

            if (changesMade) {
                await setMusicians(updatedMusicians);
                showStatus(`Automatically seated ${unseatedIndex} musician(s) onto the stage in a grid pattern.`, 'success');
            } else {
                showStatus("All musicians are already seated.", 'info');
            }
        }
        
        // --- Export/Import Functions ---
        
        /** Exports the current class data to a downloadable JSON file. */
        async function exportClassData() {
            if (!appState.currentClassId) {
                showStatus("Please select or create a class first.", 'error');
                return;
            }

            const currentClass = appState.classes[appState.currentClassId];
            if (!currentClass) return;

            try {
                // Format JSON nicely for readability
                const data = JSON.stringify(currentClass, null, 2); 
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create a temporary link element to trigger download
                const a = document.createElement('a');
                a.href = url;
                // Sanitize and create filename
                const filename = `${currentClass.name.replace(/[^a-z0-9]/gi, '_')}_Ensemble_Chart.json`;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Clean up the object URL

                showStatus(`Data for "${currentClass.name}" downloaded as ${filename}.`, 'success');
            } catch (error) {
                console.error("Error exporting class data:", error);
                showStatus("Failed to export class data. Check console for details.", 'error');
            }
        }
        
        /** Handles the file input change event to import a class JSON file. */
        async function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== "application/json" && !file.name.toLowerCase().endsWith('.json')) {
                showStatus("Invalid file type. Please select a .json file.", 'error');
                event.target.value = ''; 
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Basic Validation Check
                    if (typeof importedData.name !== 'string' || !Array.isArray(importedData.musicians)) {
                        showStatus("Invalid file structure. File must contain 'name' (string) and 'musicians' (array).", 'error');
                        return;
                    }

                    // Ensure the imported class name is unique or append a number
                    let baseName = importedData.name.trim() || 'Imported Class';
                    let newClassName = baseName;
                    let counter = 1;
                    
                    const existingNames = Object.values(appState.classes).map(c => c.name);
                    while (existingNames.includes(newClassName)) {
                        newClassName = `${baseName} (${counter++})`;
                    }

                    // Create a new unique ID for the imported class
                    const newId = generateUniqueId();
                    
                    // Sanitize imported musicians data
                    const sanitizedMusicians = importedData.musicians.map(m => ({
                        id: m.id || generateUniqueId(),
                        name: (m.name && typeof m.name === 'string' && m.name.trim()) ? m.name.trim() : 'Unnamed Musician',
                        // Ensure x/y are valid numbers if present
                        x: (m.x !== undefined && m.x !== null && !isNaN(m.x)) ? Math.round(m.x) : undefined,
                        y: (m.y !== undefined && m.y !== null && !isNaN(m.y)) ? Math.round(m.y) : undefined
                    }));

                    // 1. Add to state
                    appState.classes[newId] = {
                        name: newClassName,
                        musicians: sanitizedMusicians
                    };
                    
                    // 2. Load the new class
                    await loadClass(newId);
                    showStatus(`Successfully imported group: "${newClassName}".`, 'success');

                } catch (error) {
                    console.error("Error processing imported JSON file:", error);
                    showStatus("Error reading or parsing the JSON file. It may be corrupted.", 'error');
                } finally {
                    // Reset file input to allow the user to import the same file again if needed
                    event.target.value = ''; 
                }
            };
            reader.onerror = () => {
                showStatus("Error reading file.", 'error');
                event.target.value = ''; 
            };
            reader.readAsText(file);
        }

        // --- Event Listeners ---

        classSelector.addEventListener('change', (e) => {
            loadClass(e.target.value);
        });
        
        // Attach download PDF function to button
        document.getElementById('download-chart-btn').addEventListener('click', downloadChartPDF);
        
        // Attach Export/Import listeners
        document.getElementById('export-class-btn').addEventListener('click', exportClassData);
        importFileInput.addEventListener('change', handleImportFile);


        document.getElementById('add-names-btn').addEventListener('click', async () => {
            const input = document.getElementById('name-input').value.trim();
            if (!input) {
                showStatus("Please paste names into the box first.", 'info');
                return;
            }

            const newNames = input.split('\n')
                .map(line => line.trim())
                .filter(name => name.length > 0)
                .map(name => ({
                    id: generateUniqueId(), 
                    name: name
                }));

            if (newNames.length > 0) {
                const currentMusicians = getCurrentMusicians();
                await setMusicians([...currentMusicians, ...newNames]);
                document.getElementById('name-input').value = ''; // Clear input
                showStatus(`Added ${newNames.length} new musicians to "${appState.classes[appState.currentClassId].name}".`, 'success');
            }
        });

        document.getElementById('seat-all-btn').addEventListener('click', seatAllUnseated);
        
        document.getElementById('clear-unseated-btn').addEventListener('click', async () => {
            if (!appState.currentClassId || getCurrentMusicians().length === 0) {
                 showStatus("No musicians loaded to clear.", 'info');
                 return;
            }

            const currentMusicians = getCurrentMusicians();
            const unseatedMusicians = currentMusicians.filter(m => m.x === undefined && m.y === undefined);

            if (unseatedMusicians.length === 0) {
                 showStatus("The unseated list is already empty.", 'info');
                 return;
            }


            const confirmed = await confirmClear(`Are you sure you want to remove all ${unseatedMusicians.length} unseated musicians from the list in "${appState.classes[appState.currentClassId].name}"? This action cannot be undone.`);

            if (confirmed) {
                // Filter the musicians list to keep ONLY those who are seated (have x and y coordinates)
                const initialCount = currentMusicians.length;
                
                const updatedMusicians = currentMusicians.filter(m => m.x !== undefined && m.y !== undefined);
                
                const removedCount = initialCount - updatedMusicians.length;

                if (removedCount > 0) {
                    await setMusicians(updatedMusicians);
                    showStatus(`Successfully removed ${removedCount} unseated musician(s) from the list.`, 'success');
                }
            }
        });

        document.getElementById('clear-stage-btn').addEventListener('click', async () => {
            if (!appState.currentClassId || getCurrentMusicians().length === 0) {
                 showStatus("No musicians loaded to clear seating.", 'info');
                 return;
            }

            const confirmed = await confirmClear(`Are you sure you want to clear the entire seating chart for "${appState.classes[appState.currentClassId].name}"? All positions will be reset.`);

            if (confirmed) {
                // Keep the names, but remove their positions (unseat everyone)
                const updatedMusicians = getCurrentMusicians().map(m => {
                    const { x, y, ...rest } = m;
                    return rest;
                });
                await setMusicians(updatedMusicians);
                showStatus("Seating chart cleared. All musicians are now unseated.", 'success');
            }
        });

        // Initialize the application
        initApp();
    </script>
</body>
</html>
